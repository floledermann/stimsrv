let Canvas = null;
try {
  Canvas = require("puppet-canvas");
}
catch(e) {
  throw new Error("puppet-canvas must be installed manually to use this browser adapter!");
}

const stream = require('stream')

const deepEqual = require("fast-deep-equal");

const warnDefaults = require("../../util/warnDefaults.js");
const resource = require("../../util/resource.js");

module.exports = function(experiment, controller) {
  
  return function(client, role) {
    
    let lastMessage = null;
    let lastMessageData = null;
    
    let taskIndex = -1;
    let currentTaskUI = null;
    let currentDisplay = null;
    let currentContext = null;
    let currentCondition = null;
    
    let imageWidth = 200;
    let imageHeight = 200;
    
    let canvasP = null;
    let ctxP = null;
    
    if (client.imageSize) {
      let [w,h] = client.imageSize.split("x").map(n => +n);
      imageWidth = w || imageWidth;
      imageHeight = h || imageHeight;
    }
    //console.log(imageWidth);
    
    canvasP = Canvas.createCanvas(imageWidth, imageHeight);
    
    canvasP.then(canvas => ctxP = canvas.getContext('2d'));
    
    let localContext = {
      clientid: client.id,
      device: client,
      role: role.role, // TODO: this should be the whole role object, but check/test this
    };

    function getResourceURL(id, path) {
      return "/static/resources/" + id + "/" + path;
    }
    
    function warn(message, data) {
      controller.warn(message, data);
    }
    
    function showCondition(task, condition) {
      
      currentCondition = condition;
      
      update();
      
    }    
    
    function renderCurrentImage(response) {
      
      //let ui = currentTaskUI.interfaces[role.role + ".display"] || currentTaskUI.interfaces["display"] || currentTaskUI.interfaces["*"];
      
      canvasP.then(canvas => ctxP.then(ctx => {
      
        if (currentDisplay) {
          if (currentDisplay.fonts) {
            for (let font of currentDisplay.fonts) {
              //console.log("Register Font: " + font.family + " from " + resource.path(font.resource));
              Canvas.registerFont(resource.path(font.resource), { family: font.family });
            }
          }
          
          let uiOptions = Object.assign({
            pixeldensity: warnDefaults.value(warn, "pixeldensity", 96),
            gamma: warnDefaults.value(warn, "gamma", 2.2),
            viewingdistance: warnDefaults.value(warn, "viewingdistance", 600),
            ambientIntensity: warnDefaults.value(warn, "ambientIntensity", 1/100)
          }, client);
            
          // set callback functions
          Object.assign(uiOptions, {
            warn: warn,
            event: function(event){ warn("Events are not supported in browser-simple client"); },
            response: function(response){ warn("Responses generated by UI are not supported in browser-simple client"); },
            getResourceURL: getResourceURL
          });
                           
          if (currentDisplay.renderToCanvas) {
            currentDisplay.renderToCanvas(ctx, currentCondition, uiOptions);
            console.log("## browser-simple rendered");
          }
          else {
            warn("Task UI is missing renderToCanvas() method required for rendering for browser-simple.");
          }
        }
        
        if (!currentDisplay || !currentDisplay.renderToCanvas) {       
          ctx.fillStyle = "#000000";
          ctx.fillRect(0,0,imageWidth,imageHeight);
        }
        
        canvas.toDataURL().then(txt => {
          let data = txt.substring(22);
          let buffer = Buffer.from(data, 'base64');
          response.write(buffer, 'binary');
          response.end(null, 'binary');
          
          //let stream = canvas.createPNGStream();
          
          //stream.pipe(response);
        
        });
        
      }));
    }
    
    let updateResponse = null;
    let updated = false;
    
    function update() {
      if (updateResponse) {
        updateResponse.send("reload");
      }
      updateResponse = null;
    }
    
    return {
      message: function(type, data) {
        lastMessage = type;
        lastMessageData = data;
        
        if (type == "condition") {        
          if (currentTaskUI === null || data.taskIndex != taskIndex || !deepEqual(currentContext, data.context)) {          
            throw new Error("Task condition without initialization", data);           
          }
          showCondition(currentTaskUI, data.condition);
        }
        
        if (type == "task init") {
          
          taskIndex = data.taskIndex;
          currentContext = data.context;
          let fullContext = Object.assign({}, currentContext, localContext);
          
          currentTaskUI = experiment.tasks[data.taskIndex].ui(fullContext);
          currentDisplay = currentTaskUI.interfaces[role.role + ".display"] || currentTaskUI.interfaces["display"] || currentTaskUI.interfaces["*"];

          if (data.condition) {
            showCondition(currentTaskUI, data.condition);
          }
        }
      },
      
      render: function(req, res) {
        if (req.path == "/image/") {
          renderCurrentImage(res); 
        }
        else if (req.path == "/update/") {
          if (updateResponse) {
            // abort old update
            updateResponse.send("");
          }
          updateResponse = res;
          if (!updated) {
            update();
          }
        }
        else {
          updated = true;
          res.render("experiment-simplebrowser.html", {
            message: lastMessage,
            data: lastMessageData,
            role: req.clientRole,
            imageSize: [imageWidth/(client.devicePixelRatio || 1), imageHeight/(client.devicePixelRatio || 1)],
            delay: experiment.settings.simpleBrowserRefresh || 5,
            backgroundColor: currentDisplay?.backgroundColor || "#000000",
            foregroundColor: currentDisplay?.foregroundColor || "#ffffff"
          });
        }
      }
      
    }
  }

}